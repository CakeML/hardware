open preamble;

open translatorLib moduleTranslatorTheory verilogPaperTheory;
open circuitExampleTheory;

val _ = new_theory "circuitExampleTranslator";

(* *** *)
(* Copied from tinyTranslateLib temporarily *)

fun hol2hardware_step_function th = let
  val (sth, funth) = th |> concl |> dest_forall
  val ret = hol2hardware_trace sth (rhs funth)
in
  REWRITE_RULE [GSYM th] ret
end;

fun intro_cvars_for_prog prog =
  list_mk_comb (``intro_cvars``, [``cvars``, prog])
  |> computeLib.RESTR_EVAL_CONV (append (decls "n2ver") (decls "w2ver"))
  |> concl |> rhs;

(* *** *)

val cvars_def = Define `cvars = ["c"]`;

val P_trans = hol2hardware_step_function P_def;
val Pv_def = P_trans |> concl |> EvalS_get_prog;
val Pv_def = Define `Pv = ^Pv_def`;
val P_trans = REWRITE_RULE [GSYM Pv_def] P_trans;

val Q_trans = hol2hardware_step_function Q_def;
val Qv_def = Q_trans |> concl |> EvalS_get_prog;
val Qv_def = Define `Qv = ^Qv_def`;
val Q_trans = REWRITE_RULE [GSYM Qv_def] Q_trans;

val R_trans = R_def |> hol2hardware_step_function |> concl |> EvalS_get_prog;

val PQ_ok_relM = Q.store_thm("PQ_ok_relM",
 `!s env ps m.
  ps = [Pv; Qv] /\
  m = <| vars := env; ps := MAP (intro_cvars cvars) ps |> /\

  (* Simulation step *)
  relM s m
  ==>
  ?m'. mstep_commit m = INR m' /\ relM (PQ s) m'`,
 rpt strip_tac \\ simp [mstep_commit_def] \\
 qspecl_then [`cvars`, `ps`, `<|vars := env; nbq := []|>`,
              `<|vars := env; nbq := []|>`, `s`, `K T`] mp_tac mstep_untainted_state \\
 impl_tac >- (rpt conj_tac
 >- rw []
 >- (rw [] \\ TRY (metis_tac [P_trans, Q_trans]) \\ EVAL_TAC \\ fs [cvars_def] \\ pop_assum mp_tac \\
     EVAL_TAC \\ simp [])
 >- (rveq \\ EVAL_TAC)
 >- metis_tac [relM_relS]
 >- (rw [valid_ps_for_module_def] \\ ntac 2 (pop_assum mp_tac) \\ EVAL_TAC \\ rw [])
 \\ rw []) \\

 rveq \\ imp_res_tac relM_relS \\
 drule (REWRITE_RULE [EvalS_def] P_trans) \\
 drule (REWRITE_RULE [EvalS_def] Q_trans) \\
 rpt strip_tac \\
 fs [sum_map_def, nbq_commit_def, PQ_def] \\
 rw [relM_def, relM_var_def]
 >- (* a *)
 (drule (mget_var_mstep_no_writes |> Q.SPEC `[q_prog; p_prog]` |> REWRITE_RULE [MAP]) \\
 disch_then (qspec_then `"a"` mp_tac) \\ impl_tac >- EVAL_TAC \\
 fs [relS_def, relS_var_def])
 >- (* b <-- duplicate code of a case *)
 (drule (mget_var_mstep_no_writes |> Q.SPEC `[q_prog; p_prog]` |> REWRITE_RULE [MAP]) \\
 disch_then (qspec_then `"b"` mp_tac) \\ impl_tac >- EVAL_TAC \\
 fs [relS_def, relS_var_def])
 >- (* c *)
 (pop_assum (qspec_then `Pv` mp_tac) \\ simp [] \\ disch_then (qspec_then `"c"` mp_tac) \\
 impl_tac >- EVAL_TAC \\ simp [cvars_def, mget_var_def, alistTheory.ALOOKUP_APPEND] \\
 EVERY_CASE_TAC \\ fs [get_var_def, get_nbq_var_def, relS_def, relS_var_def, WORD_def])
 \\ (* d <-- duplicate code of c case *)
 (pop_assum (qspec_then `Qv` mp_tac) \\ simp [] \\ disch_then (qspec_then `"d"` mp_tac) \\
 impl_tac >- EVAL_TAC \\ simp [cvars_def, mget_var_def, alistTheory.ALOOKUP_APPEND] \\
 EVERY_CASE_TAC \\ fs [get_var_def, get_nbq_var_def, relS_def, relS_var_def, WORD_def]));

(* Experiment: *)

val mrun_step = Q.store_thm("mrun_step",
 `!m m' n. mrun m (SUC n) = INR m' <=> ?m''. mstep_commit m = INR m'' /\ mrun m'' n = INR m'`,
 rw [mrun_def, sum_funpowM_def] \\ Cases_on `mstep_commit m` \\ simp [sum_bind_def]);

val mstep_commit_expand = Q.store_thm("mstep_commit_expand",
 `!m m'. mstep_commit m = INR m' ==> m' = <| vars := m'.vars; ps := m.ps |>`,
 rw [mstep_commit_def] \\ imp_res_tac sum_map_INR \\ fs [sum_map_def, module_component_equality]);

val PQ_ok_FUNPOW_relM = Q.store_thm("PQ_ok_FUNPOW_relM",
 `!n s env ps m.
  ps = [Pv; Qv] /\
  m = <|vars := env; ps := MAP (intro_cvars cvars) ps|> /\
  relM s m ==>
  ?m'. mrun m n = INR m' /\ relM (FUNPOW PQ n s) m'`,
 Induct >- fs [mrun_def, sum_funpowM_def] \\
 rpt strip_tac \\ rewrite_tac [FUNPOW] \\
 drule PQ_ok_relM \\ rpt (disch_then drule) \\ strip_tac \\
 first_x_assum (qspec_then `PQ s` mp_tac) \\
 disch_then drule \\ disch_then (qspecl_then [`m'.vars`, `m'`] mp_tac) \\
 impl_tac >- (imp_res_tac mstep_commit_expand \\ rveq \\ fs []) \\
 strip_tac \\ simp [] \\ qexists_tac `m''` \\ rveq \\ fs [mrun_step]);

(* Package the result into a form appropriate for the paper (lift step_ok to Verilog code) *)

val get_var_def = Define `
 get_var Γ name = case ALOOKUP Γ name of
                      NONE => INL UnknownVariable
                    | SOME v => INR v`;

val state_shape_def = Define `
 state_shape Γ a b c d = (get_var Γ "a" = INR (w2ver a) /\
                          get_var Γ "b" = INR (w2ver b) /\
                          get_var Γ "c" = INR (w2ver c) /\
                          get_var Γ "d" = INR (w2ver d))`;

(* Note that we use verilogPaperTheory rather than verilogTheory here *)
val PQ_ok_verilog = Q.store_thm("PQ_ok_verilog",
 `!ps Γ n (a:word8) (b:word8) (c:word8) (d:word8).
 ps = MAP (intro_cvars ["c"]) [Pv; Qv] /\
 n >= 2 /\ state_shape Γ a b c d /\ a <=+ 5w /\ b <=+ 5w
 ==>
 ?Γ'. run ps Γ n = INR Γ' /\ get_var Γ' "d" = INR (w2ver (b + a))`,
 rewrite_tac [state_shape_def, run_mrun, GSYM cvars_def] \\
 rpt strip_tac \\
 qspecl_then [`n`, `<| a := a; b := b; c := c; d := d|>`, `Γ`] mp_tac PQ_ok_FUNPOW_relM \\
 simp [] \\ impl_tac >- (rveq \\ fs [relM_def, relM_var_def, mget_var_def, get_var_def, WORD_def]) \\
 strip_tac \\ simp [sum_map_def] \\
 qspecl_then [`n`, `<|a := a; b := b; c := c; d := d|>`] mp_tac PQ_ok \\
 fs [relM_def, relM_var_def, WORD_def, mget_var_def, get_var_def]);

(*

pp example circuit:

open verilogPrintLib;

Pv_def |> concl |> rhs (*|> intro_cvars_for_prog*) |> vprog_print |> print
Qv_def |> concl |> rhs (*|> intro_cvars_for_prog*) |> vprog_print |> print

R_trans |> vprog_print |> print

*)

(** Another example for the paper **)

val word_xor_1_2 = save_thm("word_xor_1_2",
                            hol2hardware_exp ``s:cstate`` ``word_xor (1w:word8) 2w``);

val _ = export_theory ();
